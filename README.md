# Инструкция по приминению GitHub 
---
Существует два репозитория - **локальный** и **удаленный**. 
_Локальный репозиторий_ хранится только на нашем компьютере, а _удаленный репозиторий_ можно создать на GitHub, чтобы делиться репозиторием с коллегами для комфортной командной работой над файлами. 

## Инициализация локального репозитория

Для начала необходимо создать папку, в которой будет лежать будущий проект. Например, создадим папку находящуюся по пути `~/dev/git_instructions`

```
$ cd ~/dev
$ mkdir git_instructions
```

Далее перейдем в эту папку и сделаем эту папку репозиторием: 

```
$ cd ~/dev/git_instructions
$ git init
```
Также `git init` выведет сообщение вида `Initialized empty Git repository in <*ваша папка с проектом*>/.git/`  (англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/»), если сделано все правильно

## Проверим состояние репозитория с помощью команды `git status`
Должно вывести такое сообщение: 
```
On brach master #название текущей ветки
No commits yet #сообщение, что еще нет коммитов
nothing to commit (create/copy files and use "git add" ti track) #сообщение "чтобы что-нибудь закоммитить, нужно сначала это создать"
```
## Добавление файла в репозиторий 

Создадим файл `README.md`: 

```
$ touch README.md 
```

Чтобы отслеживать состояние файла, можно использовать команду `git add --all` (от англ. `add` — «добавить» + от англ. `all` — **«всё»). Ключ, или флаг, `--all` позволяет подготовить к сохранению все файлы в репозитории.
Также можно добавлять отдельно файл без ключа `--all`
```
$ git add --all
$ git add README.md 
```
Проверим статус: 
```
$ git status 
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   README.md
```
Результат в обоих случаях будет идентичным. Файлы будут отмечены зеленым, и теперь будут отслеживаться и готовы к сохранению, т.е. к **коммиту** 

Однако команда `git add` **не сохраняет**, а лишь **запоминает** текущее содержимое файла. 

## Коммит `git commit`

Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет "откатиться" назад.

Сделать коммит можно командой `git commit` c ключом `-m` (от англ. message — «сообщение»), который присваивает коммиту сообщение.
Обычно в таком сообщении поясняется, в чём именно состояли изменения.

Перейдем в папку с нашим первым проектом и выполним commit: 

```
$ git commit -m ‘Мой первый коммит!’ 
```

После нажатия `Enter` текущая версия файлов будет сохранена в репозитории с сообщением `Мой первый коммит!`. Коммит (по названию команды `git commit`) — это по сути список файлов с их контентом. 
```
[master d2b644e] Мой первый коммит!
 1 file changed, 21 insertions(+), 20 deletions(-)
```

Команда `git commit` выведет информацию о коммите.
- **[master (root-commit) baa3b6e]** значит:
коммит был в ветке master;
- **d2b644e** — сокращённый идентификатор коммита
- **1 file changed, 21 insertions(+), 20 deletions(-)**:
изменился файл `README.md`; двадцать одна строка была добавлена и двадцать удалено 

## Генерация SSH ключа для подключения к удаленному репозиторию GitHub 

### Инструкция по генерации SSH-ключа
Для генерации SSH-пары можно использовать программу `ssh-keygen`. Откроем терминал и введем следующую команду.
```
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```
или 
```
$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```

После ввода отобразится такое сообщение: 

```
> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи 
```
Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите `Enter`.
```
> Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter] 
```

## Привязка публичного ключа SSH к GitHub 
### Инструкция по связыванию SSH-ключа и GitHub-аккаунта

1. После выполнения команды `ssh-keygen` будет создано два файла — `id_ed25519` и `id_ed25519.pub` (или `id_rsa` и `id_rsa.pub` — в зависимости от того, какой алгоритм вы использовали):
`id_ed25519/id_rsa` — приватный ключ (файл без .pub в конце)
`id_ed25519.pub/id_rsa.pub` — публичный ключ (на это указывает расширение .pub).
Скопируйте содержимое файла с публичным ключом в буфер обмена.
```
# скопировать содержимое ключа в буфер обмена:
$ clip < ~/.ssh/id_rsa.pub
# для ed25519:
$ clip < ~/.ssh/id_ed25519.pub 
```
2. Перейдите на **GitHub** и выберите пункт **Settings** (англ. «настройки») в меню аккаунта.
3. В меню слева нажмите на пункт **SSH and GPG keys**.
4. В открывшейся вкладке выберите **New SSH key** (англ. «новый SSH-ключ»).
5. В поле **Title** (англ. «заголовок») напишите название ключа. Например, **Personal key**.
6. В поле **Key type** должно быть **Authentication Key** (англ. «ключ аутентификации»).
7. В поле **Key** скопируйте ваш ключ из буфера обмена.
8. Нажмите на кнопку **Add SSH key** (англ. «добавить SSH-ключ»).
9. Проверьте правильность ключа с помощью следующей команды.
```
$ ssh -T git@github.com 
```
Если это первый раз, когда вы используете **Git**, чтобы поделиться проектом на **GitHub**, появится похожее предупреждение.
```
The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?is
```
Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите **yes**, чтобы продолжить. Вы увидите приветствие на экране.
```
Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.
```
## Связываем удаленный и локальный репозитории
### Привязать удалённый репозиторий к локальному — `git remote add`
Перейдите на страницу удалённого репозитория, выберите тип **SSH** и скопируйте **URL**.
Откройте консоль, перейдите в каталог локального репозитория и введите команду `git remote add` (от англ. remote — «удалённый» и add — «добавить»).
```
$ cd ~/dev/git_istruction
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/git_instruction.git
```
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово `origin`
### Убедиться, что репозитории связаны, — `git remote -v`
```
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```
## Синхронизация локального и удаленного репозиториев
### Отправить изменения на удалённый репозиторий — `git push`
В первый раз эту команду нужно вызвать с флагом `-u` и параметрами `origin` (имя удалённого репозитория) и `main` или `master` (название текущей ветки). Флаг `-u` свяжет локальную ветку с одноимённой удалённой. 
```
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master. 
```
Появится такое сообщение: 
```
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 16 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 1.78 KiB | 1.78 MiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:<User>/mem.git
   7420aaa..c8d6a3b  master -> master
branch 'master' set up to track 'origin/master'.
```
Все готово! 



test